//
//  VisualComparisonTests.swift
//  footballProTests
//
//  Pixel-perfect comparison between Swift AnimDecoder output and Python decoder fixtures.
//  Fixtures generated by tools/generate_test_fixtures.py.
//

import Foundation
import Testing
import CoreGraphics
@testable import footballPro

@Suite("Visual Comparison Tests")
struct VisualComparisonTests {

    // MARK: - Fixture Loading

    struct SpriteFixture: Decodable {
        let name: String
        let spriteID: Int
        let width: Int
        let height: Int
        let pixels: [UInt8]  // first 128 pixel values
    }

    private func fixturesURL() -> URL {
        URL(fileURLWithPath: #filePath)
            .deletingLastPathComponent()
            .appendingPathComponent("Fixtures", isDirectory: true)
            .appendingPathComponent("sprite_fixtures.json")
    }

    private func loadFixtures() throws -> [SpriteFixture] {
        let url = fixturesURL()
        guard FileManager.default.fileExists(atPath: url.path) else {
            throw FixtureError.notGenerated
        }
        let data = try Data(contentsOf: url)
        return try JSONDecoder().decode([SpriteFixture].self, from: data)
    }

    private func animDatURL() -> URL {
        URL(fileURLWithPath: #filePath)
            .deletingLastPathComponent()
            .deletingLastPathComponent()
            .appendingPathComponent("FBPRO_ORIGINAL", isDirectory: true)
            .appendingPathComponent("ANIM.DAT")
    }

    enum FixtureError: Error {
        case notGenerated
        case animNotFound(String)
        case spriteNotFound(String, Int)
    }

    // MARK: - Comparison Tests

    @Test("Swift decoder matches Python for RCSTAND sprite 0")
    func testMatchRCSTAND() throws {
        try compareSprite(name: "RCSTAND", spriteID: 0)
    }

    @Test("Swift decoder matches Python for SKRUN sprite 0")
    func testMatchSKRUN() throws {
        try compareSprite(name: "SKRUN", spriteID: 0)
    }

    @Test("Swift decoder matches Python for LMSTAND sprite 0")
    func testMatchLMSTAND() throws {
        try compareSprite(name: "LMSTAND", spriteID: 0)
    }

    @Test("Swift decoder matches Python for QBPSET sprite 0")
    func testMatchQBPSET() throws {
        try compareSprite(name: "QBPSET", spriteID: 0)
    }

    @Test("Swift decoder matches Python for RBRNWB sprite 0")
    func testMatchRBRNWB() throws {
        try compareSprite(name: "RBRNWB", spriteID: 0)
    }

    // MARK: - Helper

    private func compareSprite(name: String, spriteID: Int) throws {
        let fixtures: [SpriteFixture]
        do {
            fixtures = try loadFixtures()
        } catch FixtureError.notGenerated {
            print("[Test] Fixtures not generated â€” run: python3 tools/generate_test_fixtures.py")
            return
        }

        guard let fixture = fixtures.first(where: { $0.name == name && $0.spriteID == spriteID }) else {
            #expect(Bool(false), "No fixture found for \(name) sprite \(spriteID)")
            return
        }

        // Decode with Swift
        let animURL = animDatURL()
        guard FileManager.default.fileExists(atPath: animURL.path) else {
            print("[Test] ANIM.DAT not available, skipping visual comparison for \(name)")
            return
        }

        var data = try Data(contentsOf: animURL)
        data.append(Data(repeating: 0, count: 256))

        let entries = AnimDecoder.parseIndex(from: data)
        guard let entry = entries.first(where: { $0.name == name }) else {
            throw FixtureError.animNotFound(name)
        }

        guard let anim = AnimDecoder.decodeAnimation(from: data, entry: entry) else {
            #expect(Bool(false), "Failed to decode animation \(name)")
            return
        }

        guard let sprite = anim.sprites[spriteID] else {
            throw FixtureError.spriteNotFound(name, spriteID)
        }

        // Compare dimensions
        #expect(sprite.width == fixture.width, "\(name) width mismatch: Swift=\(sprite.width), Python=\(fixture.width)")
        #expect(sprite.height == fixture.height, "\(name) height mismatch: Swift=\(sprite.height), Python=\(fixture.height)")

        // Compare first 128 pixel values
        let compareCount = min(128, min(sprite.pixels.count, fixture.pixels.count))
        var mismatches = 0
        for i in 0..<compareCount {
            if sprite.pixels[i] != fixture.pixels[i] {
                mismatches += 1
                if mismatches <= 5 {
                    print("[VisualComparison] \(name)[\(spriteID)] pixel \(i): Swift=\(sprite.pixels[i]), Python=\(fixture.pixels[i])")
                }
            }
        }
        #expect(mismatches == 0, "\(name) sprite \(spriteID) has \(mismatches) pixel mismatches in first \(compareCount) values")
    }
}
