//
//  PlayAnimationBlueprint.swift
//  footballPro
//
//  Complete animation path data for all 22 players on a play.
//  Generated by PlayBlueprintGenerator, consumed by FPSFieldView's TimelineView loop.
//

import SwiftUI

// MARK: - Play Animation Blueprint

/// Describes the complete animation for a single play — all 22 player paths + ball path.
public struct PlayAnimationBlueprint: Equatable { // Public
    public let id: UUID = UUID()
    public let offensivePaths: [AnimatedPlayerPath]   // 11 offensive players
    public let defensivePaths: [AnimatedPlayerPath]   // 11 defensive players
    public let ballPath: BallAnimationPath
    public let totalDuration: Double                   // Seconds (typically 2.5–4.5)
    public let phases: [AnimationPhase]

    // Equatable by identity only (each blueprint is unique)
    public static func == (lhs: PlayAnimationBlueprint, rhs: PlayAnimationBlueprint) -> Bool {
        lhs.id == rhs.id
    }
}

// MARK: - Animated Player Path

/// A single player's full movement path during the play, expressed as time-keyed waypoints.
public struct AnimatedPlayerPath { // Public
    public let playerIndex: Int              // Index in offensePlayers / defensePlayers array
    public let role: PlayerRole
    public let waypoints: [AnimationWaypoint]
}

// MARK: - Animation Waypoint

/// A position the player should reach at a given normalized time, with a speed hint for interpolation.
public struct AnimationWaypoint { // Public
    public let position: CGPoint
    public let time: Double                  // 0.0 – 1.0 (fraction of totalDuration)
    public let speed: WaypointSpeed

    public init(position: CGPoint, time: Double, speed: WaypointSpeed) {
        self.position = position
        self.time = time
        self.speed = speed
    }
}

// MARK: - Waypoint Speed

/// How fast the player is moving at this waypoint — affects interpolation easing.
public enum WaypointSpeed: Int { // Public
    case slow = 0       // Blocking stance, backpedaling
    case normal = 1     // Jogging / zone drops
    case fast = 2       // Running routes
    case sprint = 3     // Fly routes, blitzing, pursuit
}

// MARK: - Ball Animation Path

/// Describes where the football is at every moment of the play.
public struct BallAnimationPath { // Public
    public let segments: [BallSegment]

    public init(segments: [BallSegment]) {
        self.segments = segments
    }
}

// MARK: - Ball Segment

/// A discrete segment of ball movement.
public enum BallSegment { // Public
    /// Ball is held by a player (e.g. QB in pocket, RB after handoff)
    case held(byPlayerIndex: Int, isOffense: Bool, startTime: Double, endTime: Double)

    /// Ball is in the air — forward pass arc
    case thrown(arcPoints: [CGPoint], startTime: Double, endTime: Double)

    /// Ball is kicked (punt / kickoff / FG)
    case kicked(arcPoints: [CGPoint], startTime: Double, endTime: Double)

    /// Ball is loose on the ground (fumble, incomplete)
    case loose(position: CGPoint, time: Double)
}

// MARK: - Animation Phase

/// Named phase of the play animation, for coordinating visual effects.
public struct AnimationPhase { // Public
    public let name: AnimationPhaseName
    public let startTime: Double             // 0.0 – 1.0
    public let endTime: Double               // 0.0 – 1.0

    public init(name: AnimationPhaseName, startTime: Double, endTime: Double) {
        self.name = name
        self.startTime = startTime
        self.endTime = endTime
    }
}

public enum AnimationPhaseName: String { // Public
    case preSnap = "pre_snap"
    case snap = "snap"
    case routesDevelop = "routes_develop"
    case resolution = "resolution"
    case yac = "yac"                  // Yards after catch / contact
    case tackle = "tackle"
}

// MARK: - Convenience Helpers

public extension PlayAnimationBlueprint { // Public extension
    /// Get the current phase for a given normalized progress (0.0–1.0)
    func currentPhase(at progress: Double) -> AnimationPhase? {
        phases.first { progress >= $0.startTime && progress < $0.endTime }
    }
}

public extension AnimatedPlayerPath { // Public extension
    /// Interpolate position at a given normalized time (0.0–1.0)
    func position(at time: Double) -> CGPoint {
        guard !waypoints.isEmpty else { return .zero }

        // Before first waypoint
        if time <= waypoints.first!.time {
            return waypoints.first!.position
        }

        // After last waypoint
        if time >= waypoints.last!.time {
            return waypoints.last!.position
        }

        // Find bracketing waypoints
        for i in 0..<(waypoints.count - 1) {
            let wp0 = waypoints[i]
            let wp1 = waypoints[i + 1]

            if time >= wp0.time && time <= wp1.time {
                // Normalize t within this segment
                let segmentDuration = wp1.time - wp0.time
                guard segmentDuration > 0 else { return wp0.position }
                let localT = (time - wp0.time) / segmentDuration

                // Apply easing based on speed
                let easedT = ease(localT, speed: wp1.speed)

                // Lerp
                let x = wp0.position.x + (wp1.position.x - wp0.position.x) * easedT
                let y = wp0.position.y + (wp1.position.y - wp0.position.y) * easedT
                return CGPoint(x: x, y: y)
            }
        }

        return waypoints.last!.position
    }

    /// Calculate facing direction (radians) at a given time
    func facingDirection(at time: Double) -> Double {
        guard waypoints.count >= 2 else { return 0 }

        // Find current segment
        for i in 0..<(waypoints.count - 1) {
            let wp0 = waypoints[i]
            let wp1 = waypoints[i + 1]

            if time >= wp0.time && time <= wp1.time {
                let dx = wp1.position.x - wp0.position.x
                let dy = wp1.position.y - wp0.position.y
                if abs(dx) > 0.1 || abs(dy) > 0.1 {
                    return atan2(dy, dx)
                }
                break
            }
        }

        // Default: face right (toward end zone)
        return 0
    }

    /// Whether the player is actively moving at this time
    func isMoving(at time: Double) -> Bool {
        guard waypoints.count >= 2 else { return false }

        for i in 0..<(waypoints.count - 1) {
            let wp0 = waypoints[i]
            let wp1 = waypoints[i + 1]

            if time >= wp0.time && time <= wp1.time {
                let dx = abs(wp1.position.x - wp0.position.x)
                let dy = abs(wp1.position.y - wp0.position.y)
                return dx > 2 || dy > 2  // Moving if destination differs by > 2 pts
            }
        }
        return false
    }

    // MARK: - Easing

    private func ease(_ t: Double, speed: WaypointSpeed) -> Double {
        switch speed {
        case .slow:
            // Ease in-out (smooth blocking)
            return t * t * (3 - 2 * t)
        case .normal:
            // Slight ease-in
            return t * t * (2 - t)
        case .fast:
            // Mostly linear with slight acceleration
            return t * (2 - t)
        case .sprint:
            // Nearly linear (full speed)
            return t
        }
    }
}

public extension BallAnimationPath { // Public extension
    /// Returns (playerIndex, isOffense) for the player holding the ball at the given time, or nil if the ball is in the air/loose.
    func ballCarrier(at time: Double) -> (playerIndex: Int, isOffense: Bool)? {
        for segment in segments {
            switch segment {
            case .held(let playerIndex, let isOffense, let startTime, let endTime):
                if time >= startTime && time <= endTime {
                    return (playerIndex, isOffense)
                }
            default:
                continue
            }
        }
        return nil
    }

    /// Returns the flat position of the ball at a given time, using raw waypoint paths instead of FPSPlayer array.
    func flatPosition(at time: Double, offensivePaths: [AnimatedPlayerPath], defensivePaths: [AnimatedPlayerPath]) -> CGPoint {
        for segment in segments {
            switch segment {
            case .held(let playerIndex, let isOffense, let startTime, let endTime):
                if time >= startTime && time <= endTime {
                    let paths = isOffense ? offensivePaths : defensivePaths
                    if playerIndex < paths.count {
                        return paths[playerIndex].position(at: time)
                    }
                }

            case .thrown(let arcPoints, let startTime, let endTime):
                if time >= startTime && time <= endTime {
                    let duration = endTime - startTime
                    guard duration > 0, !arcPoints.isEmpty else { continue }
                    let localT = (time - startTime) / duration
                    let index = min(Int(localT * Double(arcPoints.count - 1)), arcPoints.count - 1)
                    let nextIndex = min(index + 1, arcPoints.count - 1)
                    let segT = localT * Double(arcPoints.count - 1) - Double(index)
                    let p0 = arcPoints[index]
                    let p1 = arcPoints[nextIndex]
                    return CGPoint(x: p0.x + (p1.x - p0.x) * segT, y: p0.y + (p1.y - p0.y) * segT)
                }

            case .kicked(let arcPoints, let startTime, let endTime):
                if time >= startTime && time <= endTime {
                    let duration = endTime - startTime
                    guard duration > 0, !arcPoints.isEmpty else { continue }
                    let localT = (time - startTime) / duration
                    let index = min(Int(localT * Double(arcPoints.count - 1)), arcPoints.count - 1)
                    let nextIndex = min(index + 1, arcPoints.count - 1)
                    let segT = localT * Double(arcPoints.count - 1) - Double(index)
                    let p0 = arcPoints[index]
                    let p1 = arcPoints[nextIndex]
                    return CGPoint(x: p0.x + (p1.x - p0.x) * segT, y: p0.y + (p1.y - p0.y) * segT)
                }

            case .loose(let position, let looseTime):
                if time >= looseTime {
                    return position
                }
            }
        }

        // Fallback: return last known position
        return .zero
    }

    /// Get ball position at a given normalized time
    func position(at time: Double, offensePlayers: [FPSPlayer], defensePlayers: [FPSPlayer]) -> CGPoint {
        for segment in segments {
            switch segment {
            case .held(let playerIndex, let isOffense, let startTime, let endTime):
                if time >= startTime && time <= endTime {
                    let players = isOffense ? offensePlayers : defensePlayers
                    if playerIndex < players.count {
                        // Assuming FPSPlayer has a 'position' property
                        // This might cause an error if FPSPlayer is internal or not defined
                        return players[playerIndex].position
                    }
                }

            case .thrown(let arcPoints, let startTime, let endTime):
                if time >= startTime && time <= endTime {
                    let duration = endTime - startTime
                    guard duration > 0 else { continue }
                    let localT = (time - startTime) / duration
                    let index = min(Int(localT * Double(arcPoints.count - 1)), arcPoints.count - 1)
                    let nextIndex = min(index + 1, arcPoints.count - 1)
                    let segT = localT * Double(arcPoints.count - 1) - Double(index)
                    let p0 = arcPoints[index]
                    let p1 = arcPoints[nextIndex]
                    return CGPoint(
                        x: p0.x + (p1.x - p0.x) * segT,
                        y: p0.y + (p1.y - p0.y) * segT
                    )
                }

            case .kicked(let arcPoints, let startTime, let endTime):
                if time >= startTime && time <= endTime {
                    let duration = endTime - startTime
                    guard duration > 0 else { continue }
                    let localT = (time - startTime) / duration
                    let index = min(Int(localT * Double(arcPoints.count - 1)), arcPoints.count - 1)
                    let nextIndex = min(index + 1, arcPoints.count - 1)
                    let segT = localT * Double(arcPoints.count - 1) - Double(index)
                    let p0 = arcPoints[index]
                    let p1 = arcPoints[nextIndex]
                    return CGPoint(
                        x: p0.x + (p1.x - p0.x) * segT,
                        y: p0.y + (p1.y - p0.y) * segT
                    )
                }

            case .loose(let position, let looseTime):
                if time >= looseTime {
                    return position
                }
            }
        }

        // Fallback: return last known position
        return .zero
    }
}